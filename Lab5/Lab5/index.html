
<!DOCTYPE html>

<html>

<head>
<title>WebGL Lab &mdash; 5 </title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script id="shader-vs" type="x-shader/x-vertex">
precision mediump float;
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aVertexUV;

    uniform mat4 uMVPMatrix;
    uniform mat4 uMVMatrix;
    uniform mat4 uNMatrix;

    varying vec4 vColor; 
    varying vec3 vNormal_CameraSpace;
    varying vec3 vVertexPos_CameraSpace;
    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = uMVPMatrix * vec4( aVertexPosition, 1.0 );
      //  vColor = aVertexColor; 
        vNormal_CameraSpace = vec3( uNMatrix * vec4( aVertexNormal, 0.0 ) );
        vVertexPos_CameraSpace = vec3( uMVMatrix * vec4( aVertexPosition, 1.0 ) );
        vVertexUV = aVertexUV;
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;
   // varying vec4 vColor; 
    varying vec3 vNormal_CameraSpace;
    varying vec3 vVertexPos_CameraSpace;
    varying vec2 vVertexUV;

    uniform vec3 uLightPos_CameraSpace;

    uniform vec4 uLightAmbient; 
    uniform vec4 uLightDiffuse; 
    uniform vec4 uLightSpecular;

    uniform float uShininess;

    uniform vec4 uMaterialAmbient; 
    uniform vec4 uMaterialDiffuse; 
    uniform vec4 uMaterialSpecular;

    uniform sampler2D uMeshTexture; 

    void main(void) 
        {
        vec4 texColor = texture2D( uMeshTexture, vVertexUV ); 

        vec3 lightVec = normalize( vec3( uLightPos_CameraSpace - vVertexPos_CameraSpace ) ); 

        vec3 eyeVec = normalize( -vec3( vVertexPos_CameraSpace ) );
        
        float ndotl = max( dot( vNormal_CameraSpace, lightVec ), 0.0 ); 

        vec4 diffuse = uLightDiffuse * ndotl;

        vec3 reflectVec = normalize( 2.0 * ndotl * vNormal_CameraSpace - lightVec );
        
        float rdotv = max( dot( reflectVec, eyeVec ), 0.0 );

        vec4 specular = vec4( 0, 0, 0, 1); 
        if ( ndotl > 0.0 ) 
            specular = uLightSpecular * pow( rdotv, uShininess ); 

        gl_FragColor = texColor * ( uLightAmbient * uMaterialAmbient + diffuse * uMaterialDiffuse ) + specular * uMaterialSpecular; 
        gl_FragColor.a = 1.0;
        //gl_FragColor = texColor;
       // gl_FragColor = uLightAmbient;
      //  gl_FragColor = vec4( vNormal, 1.0 );
        }
</script>

<script id="textureShader-vs" type="x-shader/x-vertex">
precision mediump float;
    attribute vec2 aVertexPosition;
    attribute vec2 aVertexUV;

    varying vec2 vVertexUV;

    void main(void) {
        vVertexUV = aVertexUV;
        gl_Position = vec4( aVertexPosition, 0, 1 );
    }
</script>

<script id="textureShader-fs" type="x-shader/x-fragment">
precision mediump float;
varying vec2 vVertexUV;

uniform sampler2D uTexture; 

void main(void) 
    {
    gl_FragColor = texture2D( uTexture, vVertexUV ); 
    //vec4 color = texture2D( uTexture, vVertexUV ); 
    //gl_FragColor = vec4( color.x, color.x, color.x, 1 );
    }
</script>

<script id="deferredGeometryShader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aVertexUV;

    uniform mat4 uMVPMatrix;
    uniform mat4 uMVMatrix;
    uniform mat4 uNMatrix;


    varying vec4 vPosition_CameraSpace;
    varying vec4 vNormal_CameraSpace;
    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = uMVPMatrix * vec4( aVertexPosition, 1 );
        vPosition_CameraSpace = uMVMatrix * vec4( aVertexPosition, 1 );
        vNormal_CameraSpace = uNMatrix * vec4( aVertexNormal, 0 );
        vVertexUV = aVertexUV;
    }
</script>

 <script id="deferredGeometryShader-fs" type="x-shader/x-fragment">
#extension GL_EXT_draw_buffers : require
    precision highp float;

    varying vec4 vPosition_CameraSpace;
    varying vec4 vNormal_CameraSpace;
    varying vec2 vVertexUV;

    uniform sampler2D uMeshTexture; 
    uniform float uShininess;
    uniform vec4 uMaterialAmbient;
    uniform vec4 uMaterialDiffuse;
    uniform vec4 uMaterialSpecular;

void main(void) 
    {
    vec4 textureColor = texture2D( uMeshTexture, vVertexUV );
     //depth = gl_FragCoord.z;
    gl_FragData[ 0 ] = vPosition_CameraSpace; 
    gl_FragData[ 0 ].a = uShininess;
    
    // Warning: do NOT normalize vec4!
    gl_FragData[ 1 ].xyz = normalize( vNormal_CameraSpace.xyz ); 
    gl_FragData[ 1 ].a = uMaterialSpecular.x;

    gl_FragData[ 2 ] = textureColor * uMaterialAmbient; 
    gl_FragData[ 2 ].a = uMaterialSpecular.y;

    gl_FragData[ 3 ] = textureColor * uMaterialDiffuse; 
    gl_FragData[ 3 ].a = uMaterialSpecular.z;
    }
</script>


<script id="deferredLightShader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec2 aVertexPosition;
    attribute vec2 aVertexUV;

    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = vec4( aVertexPosition, 0.5, 1 );
        vVertexUV = aVertexUV;
    }
</script>

 <script id="deferredLightShader-fs" type="x-shader/x-fragment">
    precision highp float;

    varying vec2 vVertexUV;

    uniform sampler2D uPositionTex_CameraSpace; 
    uniform sampler2D uNormalTex_CameraSpace; 
    uniform sampler2D uAlbedoTex; 
    uniform sampler2D uMaterialDiffuseTex; 

    uniform vec3 uLightPos_CameraSpace;

    uniform vec4 uLightAmbient; 
    uniform vec4 uLightDiffuse; 
    uniform vec4 uLightSpecular;

void main(void) 
    {
     // This texture stores position + shininess 
    vec4 temp = texture2D( uPositionTex_CameraSpace, vVertexUV );
    vec3 vertexPos_CameraSpace = temp.xyz;
    float shininess = temp.w;

    temp = texture2D( uNormalTex_CameraSpace, vVertexUV );
    vec3 vertexNormal_CameraSpace = temp.xyz;
    vec4 materialSpecular = vec4( temp.w, 0, 0, 1 );

    temp = texture2D( uAlbedoTex, vVertexUV );  
    vec4 albedo = vec4( temp.xyz, 1 );
    materialSpecular.y = temp.w;

    temp = texture2D( uMaterialDiffuseTex, vVertexUV );
    vec4 materialDiffuse = vec4( temp.xyz, 1 ); 
    materialSpecular.z = temp.w;
     
    vec3 lightVec = normalize( uLightPos_CameraSpace - vertexPos_CameraSpace ); 

    vec3 eyeVec = normalize( -vertexPos_CameraSpace );
      
    float ndotl = max( dot( vertexNormal_CameraSpace, lightVec ), 0.0 ); 

    vec4 diffuse = uLightDiffuse * ndotl;

    vec3 reflectVec = normalize( 2.0 * ndotl * vertexNormal_CameraSpace - lightVec );
        
    float rdotv = max( dot( reflectVec, eyeVec ), 0.0 );

    vec4 specular = vec4( 0, 0, 0, 1); 
    if ( ndotl > 0.0 ) 
        specular = uLightSpecular * pow( rdotv, shininess ); 

    gl_FragColor = albedo * uLightAmbient + diffuse * materialDiffuse + specular * materialSpecular; 
    gl_FragColor.a = 1.0;
    
   // gl_FragColor = materialSpecular;
   // gl_FragColor = texture2D( uNormalTex_CameraSpace, vVertexUV ); 
    }
</script>

    
<script id="SSAOShader-vs" type="x-shader/x-vertex">
    precision highp float;
    attribute vec2 aVertexPosition;
    attribute vec2 aVertexUV;

    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = vec4( aVertexPosition, 0, 1 );
        vVertexUV = aVertexUV;
    }
</script>

 <script id="SSAOShader-fs" type="x-shader/x-fragment">
    precision highp float;
    const int MAXIUM_SAMPLE_POINTS_SUPPORTED = 64;
    const float RADIUS = 1.0;
    varying vec2 vVertexUV;

    uniform sampler2D uPositionTex_CameraSpace; 
    uniform sampler2D uNormalTex_CameraSpace; 
    uniform sampler2D uNoiseTex;

    uniform vec2 uNoiseScale;
    uniform vec3 uSamplePoints[ MAXIUM_SAMPLE_POINTS_SUPPORTED ];
    uniform int uSampleNum;
    uniform mat4 uPMatrix;

    void main(void) {
        vec3 normalVec = texture2D( uNormalTex_CameraSpace ,vVertexUV ).xyz;
        vec3 originPoint = texture2D( uPositionTex_CameraSpace ,vVertexUV ).xyz;
        
        // Generate TBN matrix
        // find random vector
        vec3 randomVec = texture2D( uNoiseTex, vVertexUV * uNoiseScale ).xyz;
        vec3 tangentVec = normalize( randomVec - normalVec * dot( normalVec, randomVec ) );
        vec3 biTangentVec = normalize( cross( normalVec, tangentVec ) );
        mat3 tbn = mat3( tangentVec, biTangentVec, normalVec );
        
        float occlusion = 0.0;
        vec3 test;
        for( int i = 0; i < MAXIUM_SAMPLE_POINTS_SUPPORTED; ++i )
            {
            if( i == uSampleNum )
                {
                break;
                }

            // This is still a vector
            // get sample vector in camera space
            vec3 samplePoint = tbn * uSamplePoints[ i ];

            // Convert to point
            samplePoint = originPoint + samplePoint * RADIUS;
            
            // Find the project point in clip space
            vec4 p = uPMatrix * vec4( samplePoint, 1 );
            vec3 projectPoint = p.xyz / p.w;
            projectPoint = ( projectPoint + vec3( 1, 1, 1 ) ) * 0.5;
            projectPoint = texture2D( uPositionTex_CameraSpace, projectPoint.xy ).xyz;
 
            // sample point is behind the projected point -> occolued
            if( -projectPoint.z <= -samplePoint.z && abs( projectPoint.z - samplePoint.z ) <= RADIUS )
                {
                occlusion += abs( 1.0 );
                }
            
            }
     
        // inverse the occlusion value, higher occlusion means darker
        occlusion = 1.0 - occlusion / ( float( uSampleNum ) );
        gl_FragColor = vec4( occlusion, occlusion, occlusion, 1 );

      //  gl_FragColor = vec4( -originPoint.z, -originPoint.z, -originPoint.z, 1 );
    }
</script>

<script type="text/javascript" src="scripts\gl-matrix\common.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\mat2.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\mat2d.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\mat3.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\mat4.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\vec3.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\vec4.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\quat.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\vec2.js"></script>


<script type="text/javascript" src="scripts\webgl-utils.js"></script>

<script type="text/javascript" src="scripts\Resources\Resource.js"></script>
<script type="text/javascript" src="scripts\Resources\ShaderResource.js"></script>

<script type="text/javascript" src="scripts\GlobalConstants.js"></script>
<script type="text/javascript" src="scripts\Controller.js"></script>
<script type="text/javascript" src="scripts\CameraController.js"></script>
<script type="text/javascript" src="scripts\RobotController.js"></script>
<script type="text/javascript" src="scripts\Transform.js"></script>
<script type="text/javascript" src="scripts\TransformStack.js"></script>
<script type="text/javascript" src="scripts\Scene.js"></script>

<script type="text/javascript" src="scripts\SceneNodes\SceneNodes.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\CameraNode.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\GeometrySceneNodes.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\MeshSceneNodes.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\PointLightSceneNode.js"></script>

<script type="text/javascript" src="scripts\shaders_setup.js"></script>
<script type="text/javascript" src="scripts\Main.js"></script>
<script type="text/javascript" src="scripts\Resources\QuadResource.js"></script>
<script type="text/javascript" src="scripts\Drawers\TextureDrawer.js"></script>
<script type="text/javascript" src="scripts\Drawers\DeferredDrawer.js"></script>
<script type="text/javascript" src="scripts\Drawers\SSAODrawer.js"></script>

</head>


<body onload="webGLStart();">

    <canvas id="WebGL-canvas" style="border: none;" width="1024" height="512"></canvas>

    <br/>

    <h4 id="LightControlOption">- Control your light</br> </br> </h4> 

    <h4 id="CameraControlOption">- Control your camera</br> </br> </h4> 
</body>


</html>

