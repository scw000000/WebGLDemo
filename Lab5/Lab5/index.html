
<!DOCTYPE html>

<html>

<head>
<title>WebGL Lab &mdash; 5 </title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<script id="shader-vs" type="x-shader/x-vertex">
precision mediump float;
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec2 aVertexUV;

    uniform mat4 uMVPMatrix;
    uniform mat4 uMVMatrix;
    uniform mat4 uNMatrix;

    varying vec4 vColor; 
    varying vec3 vNormal_CameraSpace;
    varying vec3 vVertexPos_CameraSpace;
    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = uMVPMatrix * vec4( aVertexPosition, 1.0 );
      //  vColor = aVertexColor; 
        vNormal_CameraSpace = vec3( uNMatrix * vec4( aVertexNormal, 0.0 ) );
        vVertexPos_CameraSpace = vec3( uMVMatrix * vec4( aVertexPosition, 1.0 ) );
        vVertexUV = aVertexUV;
    }
</script>

<script id="shader-fs" type="x-shader/x-fragment">
precision mediump float;
   // varying vec4 vColor; 
    varying vec3 vNormal_CameraSpace;
    varying vec3 vVertexPos_CameraSpace;
    varying vec2 vVertexUV;

    uniform vec3 uLightPos_CameraSpace;

    uniform vec4 uLightAmbient; 
    uniform vec4 uLightDiffuse; 
    uniform vec4 uLightSpecular;

    uniform float uShininess;

    uniform vec4 uMaterialAmbient; 
    uniform vec4 uMaterialDiffuse; 
    uniform vec4 uMaterialSpecular;

    uniform sampler2D uMeshTexture; 

    void main(void) 
        {
        vec4 texColor = texture2D( uMeshTexture, vVertexUV ); 

        vec3 lightVec = normalize( vec3( uLightPos_CameraSpace - vVertexPos_CameraSpace ) ); 

        vec3 eyeVec = normalize( -vec3( vVertexPos_CameraSpace ) );
        
        float ndotl = max( dot( vNormal_CameraSpace, lightVec ), 0.0 ); 

        vec4 diffuse = uLightDiffuse * ndotl;

        vec3 reflectVec = normalize( 2.0 * ndotl * vNormal_CameraSpace - lightVec );
        
        float rdotv = max( dot( reflectVec, eyeVec ), 0.0 );

        vec4 specular = vec4( 0, 0, 0, 1); 
        if ( ndotl > 0.0 ) 
            specular = uLightSpecular * pow( rdotv, uShininess ); 

        gl_FragColor = texColor * ( uLightAmbient * uMaterialAmbient + diffuse * uMaterialDiffuse ) + specular * uMaterialSpecular; 
        gl_FragColor.a = 1.0;
        //gl_FragColor = texColor;
       // gl_FragColor = uLightAmbient;
      //  gl_FragColor = vec4( vNormal, 1.0 );
        }
</script>

<script id="textureShader-vs" type="x-shader/x-vertex">
precision mediump float;
    attribute vec2 aVertexPosition;
    attribute vec2 aVertexUV;

    varying vec2 vVertexUV;

    void main(void) {
        vVertexUV = aVertexUV;
        gl_Position = vec4( aVertexPosition, 0, 1 );
    }
</script>

<script id="textureShader-fs" type="x-shader/x-fragment">
precision mediump float;
varying vec2 vVertexUV;

uniform sampler2D uTexture; 

void main(void) 
    {
    gl_FragColor = texture2D( uTexture, vVertexUV ); 
    //vec4 color = texture2D( uTexture, vVertexUV ); 
    //gl_FragColor = vec4( color.x, color.x, color.x, 1 );
    }
</script>

<script id="deferredGeometryShader-vs" type="x-shader/x-vertex">#version 300 es
    precision mediump float;
    layout (location = 0) in vec3 aVertexPosition;
    layout (location = 1) in vec3 aVertexNormal;
    layout (location = 2) in vec2 aVertexUV;

    uniform mat4 uMVPMatrix;
    uniform mat4 uMVMatrix;
    uniform mat4 uNMatrix;

    out vec4 vPosition_CameraSpace;
    out vec4 vNormal_CameraSpace;
    out vec2 vVertexUV;

    void main(void) {
        gl_Position = uMVPMatrix * vec4( aVertexPosition, 1 );
        vPosition_CameraSpace = uMVMatrix * vec4( aVertexPosition, 1 );
        vNormal_CameraSpace = uNMatrix * vec4( aVertexNormal, 0 );
        vVertexUV = aVertexUV;
    }
</script>

 <script id="deferredGeometryShader-fs" type="x-shader/x-fragment">#version 300 es
    precision mediump float;

    in vec4 vPosition_CameraSpace;
    in vec4 vNormal_CameraSpace;
    in vec2 vVertexUV;

    uniform sampler2D uMeshTexture; 
    uniform float uShininess;
    uniform vec4 uMaterialAmbient;
    uniform vec4 uMaterialDiffuse;
    uniform vec4 uMaterialSpecular;
    
     layout (location = 0) out vec4 oPosition;
     layout (location = 1) out vec4 oNormal;
     layout (location = 2) out vec4 oAlbedo;
     layout (location = 3) out vec4 oDiffuse;

void main(void) 
    {
    vec4 textureColor = texture( uMeshTexture, vec2( vVertexUV ) );
      oPosition = vPosition_CameraSpace; 
      oPosition.a = uShininess;
    
    // Warning: do NOT normalize vec4!
      oNormal.xyz = normalize( vNormal_CameraSpace.xyz ); 
      oNormal.a = uMaterialSpecular.x;

      oAlbedo = textureColor * uMaterialAmbient; 
      oAlbedo.a = uMaterialSpecular.y;

      oDiffuse = textureColor * uMaterialDiffuse; 
      oDiffuse.a = uMaterialSpecular.z;
    }
</script>


<script id="deferredLightShader-vs" type="x-shader/x-vertex">
    precision mediump float;
    attribute vec2 aVertexPosition;
    attribute vec2 aVertexUV;

    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = vec4( aVertexPosition, 0.5, 1 );
        vVertexUV = aVertexUV;
    }
</script>

 <script id="deferredLightShader-fs" type="x-shader/x-fragment">
    precision mediump float;
    const int MAXIMUM_LIGHT_SUPPORTED = 50;
    varying vec2 vVertexUV;

    uniform sampler2D uPositionTex_CameraSpace; 
    uniform sampler2D uNormalTex_CameraSpace; 
    uniform sampler2D uAlbedoTex; 
    uniform sampler2D uMaterialDiffuseTex; 
    uniform sampler2D uBlurTex; 

    uniform int uLightNum;

    uniform vec3 uLightPos_CameraSpace[ MAXIMUM_LIGHT_SUPPORTED ];
    uniform vec4 uLightAmbient[ MAXIMUM_LIGHT_SUPPORTED ]; 
    uniform vec4 uLightDiffuse[ MAXIMUM_LIGHT_SUPPORTED ]; 
    uniform vec4 uLightSpecular[ MAXIMUM_LIGHT_SUPPORTED ];

    uniform int uUseSSAO;

void main(void) 
    {
     // This texture stores position + shininess 
    vec4 temp = texture2D( uPositionTex_CameraSpace, vVertexUV );
    vec3 vertexPos_CameraSpace = temp.xyz;
    float shininess = temp.w;

    temp = texture2D( uNormalTex_CameraSpace, vVertexUV );
    vec3 vertexNormal_CameraSpace = temp.xyz;
    vec4 materialSpecular = vec4( temp.w, 0, 0, 1 );

    temp = texture2D( uAlbedoTex, vVertexUV );  
    vec4 albedo = vec4( temp.xyz, 1 ) * ( uUseSSAO == 1 ? texture2D( uBlurTex, vVertexUV ).x: 1.0 );
    materialSpecular.y = temp.w;

    temp = texture2D( uMaterialDiffuseTex, vVertexUV );
    vec4 materialDiffuse = vec4( temp.xyz, 1 ); 
    materialSpecular.z = temp.w;
    
    gl_FragColor = vec4( 0.0 );
    for( int i = 0; i < MAXIMUM_LIGHT_SUPPORTED; ++i )
        {
        if( i == uLightNum )
            {
            break;
            }
        vec3 lightVec = normalize( uLightPos_CameraSpace[ i ] - vertexPos_CameraSpace ); 

        vec3 eyeVec = normalize( -vertexPos_CameraSpace );
      
        float ndotl = max( dot( vertexNormal_CameraSpace, lightVec ), 0.0 ); 

        vec4 diffuse = uLightDiffuse[ i ] * ndotl;

        vec3 reflectVec = normalize( 2.0 * ndotl * vertexNormal_CameraSpace - lightVec );
        
        float rdotv = max( dot( reflectVec, eyeVec ), 0.0 );

        vec4 specular = vec4( 0, 0, 0, 1); 
        if ( ndotl > 0.0 ) 
            specular = uLightSpecular[ i ] * pow( rdotv, shininess ); 

        gl_FragColor += albedo * uLightAmbient[ i ] + diffuse * materialDiffuse + specular * materialSpecular; 
        }

   // vec3 lightVec = normalize( uLightPos_CameraSpace - vertexPos_CameraSpace ); 

 //   vec3 eyeVec = normalize( -vertexPos_CameraSpace );
      
  //  float ndotl = max( dot( vertexNormal_CameraSpace, lightVec ), 0.0 ); 

  //  vec4 diffuse = uLightDiffuse * ndotl;

  //  vec3 reflectVec = normalize( 2.0 * ndotl * vertexNormal_CameraSpace - lightVec );
        
 //   float rdotv = max( dot( reflectVec, eyeVec ), 0.0 );

  //  vec4 specular = vec4( 0, 0, 0, 1); 
  //  if ( ndotl > 0.0 ) 
 //       specular = uLightSpecular * pow( rdotv, shininess ); 

  //  gl_FragColor = albedo * uLightAmbient + diffuse * materialDiffuse + specular * materialSpecular; 
    gl_FragColor.a = 1.0;
    
   // gl_FragColor = materialSpecular;
   // gl_FragColor = texture2D( uBlurTex, vVertexUV ); 
    }
</script>

    
<script id="SSAOShader-vs" type="x-shader/x-vertex">
    precision mediump float;
    attribute vec2 aVertexPosition;
    attribute vec2 aVertexUV;

    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = vec4( aVertexPosition, 0, 1 );
        vVertexUV = aVertexUV;
    }
</script>

 <script id="SSAOShader-fs" type="x-shader/x-fragment">
    precision mediump float;
    const int MAXIUM_SAMPLE_POINTS_SUPPORTED = 300;
    varying vec2 vVertexUV;

    uniform sampler2D uPositionTex_CameraSpace; 
    uniform sampler2D uNormalTex_CameraSpace; 
    uniform sampler2D uNoiseTex;

    uniform vec2 uNoiseScale;
    uniform vec3 uSamplePoints[ MAXIUM_SAMPLE_POINTS_SUPPORTED ];
    uniform int uSampleNum;
    uniform mat4 uPMatrix;
    uniform float uSampleRadius;
    uniform float uSSAOPower;

    void main(void) {
        vec3 normalVec = texture2D( uNormalTex_CameraSpace ,vVertexUV ).xyz;
        vec3 originPoint = texture2D( uPositionTex_CameraSpace ,vVertexUV ).xyz;
        
        // Generate TBN matrix
        // find random vector
        vec3 randomVec = texture2D( uNoiseTex, vVertexUV * uNoiseScale ).xyz;
        vec3 tangentVec = normalize( randomVec - normalVec * dot( normalVec, randomVec ) );
        vec3 biTangentVec = normalize( cross( normalVec, tangentVec ) );
        mat3 tbn = mat3( tangentVec, biTangentVec, normalVec );
        
        float occlusion = 0.0;
        vec3 test;
        for( int i = 0; i < MAXIUM_SAMPLE_POINTS_SUPPORTED; ++i )
            {
            if( i == uSampleNum )
                {
                break;
                }

            // This is still a vector
            // get sample vector in camera space
            vec3 samplePoint = tbn * uSamplePoints[ i ];

            // Convert to point
            samplePoint = originPoint + samplePoint * uSampleRadius;
            
            // Find the project point in clip space
            vec4 p = uPMatrix * vec4( samplePoint, 1 );
            vec3 projectPoint = p.xyz / p.w;
            projectPoint = ( projectPoint + vec3( 1, 1, 1 ) ) * 0.5;
            projectPoint = texture2D( uPositionTex_CameraSpace, projectPoint.xy ).xyz;
 
            // sample point is behind the projected point -> occolued
            occlusion += ( -projectPoint.z <= -samplePoint.z && abs( projectPoint.z - samplePoint.z ) <= uSampleRadius ) ? 1.0: 0.0;
            }
     
        // inverse the occlusion value, higher occlusion means darker
        occlusion = pow( 1.0 - occlusion / ( float( uSampleNum ) ), uSSAOPower );
        gl_FragColor = vec4( occlusion, occlusion, occlusion, 1 );

      //  gl_FragColor = vec4( -originPoint.z, -originPoint.z, -originPoint.z, 1 );
    }
</script>

<script id="blurShader-vs" type="x-shader/x-vertex">
    precision mediump float;
    attribute vec2 aVertexPosition;
    attribute vec2 aVertexUV;

    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = vec4( aVertexPosition, 0, 1 );
        vVertexUV = aVertexUV;
    }
</script>


 <script id="blurShader-fs" type="x-shader/x-fragment">
    precision mediump float;
    const int NOISE_TEXTURE_SIZE = 4;
    const int HALF_NOISE_TEXTURE_SIZE = NOISE_TEXTURE_SIZE / 2;
    const int SAMPLE_COUNT = ( HALF_NOISE_TEXTURE_SIZE * 2 + 1 ) * ( HALF_NOISE_TEXTURE_SIZE * 2 + 1 );
    varying vec2 vVertexUV;

    uniform sampler2D uSSAOTex;
    uniform vec2 uInvTexureSize;

    void main(void) {

        gl_FragColor = vec4( 0 );
        for( int x = -HALF_NOISE_TEXTURE_SIZE; x <= HALF_NOISE_TEXTURE_SIZE; ++x )
            {
            for( int y = -HALF_NOISE_TEXTURE_SIZE; y <= HALF_NOISE_TEXTURE_SIZE; ++y )
                {
                vec2 shift = vec2( x, y ) * uInvTexureSize;
                gl_FragColor += texture2D( uSSAOTex, shift + vVertexUV );
                }
            }
        gl_FragColor /= float( SAMPLE_COUNT );
    }
</script>


<script id="skyShader-vs" type="x-shader/x-vertex">
precision mediump float;
    attribute vec3 aVertexPosition;
    attribute vec2 aVertexUV;

    uniform mat4 uMVPMatrix;

    varying vec2 vVertexUV;

    void main(void) {
        gl_Position = uMVPMatrix * vec4( aVertexPosition, 1.0 );
        vVertexUV = aVertexUV;
    }
</script>

<script id="skyShader-fs" type="x-shader/x-fragment">
precision mediump float;
    varying vec2 vVertexUV;

    uniform sampler2D uMeshTexture; 

    void main(void) 
        {
        gl_FragColor = texture2D( uMeshTexture, vVertexUV ); 
     //   gl_FragColor = vec4( 1, 0, 0, 1 );
        }
</script>

<script id="lightCubeShader-vs" type="x-shader/x-vertex">
precision mediump float;
    attribute vec3 aVertexPosition;

    uniform mat4 uMVPMatrix;

    void main(void) {
        gl_Position = uMVPMatrix * vec4( aVertexPosition, 1.0 );
    }
</script>

<script id="lightCubeShader-fs" type="x-shader/x-fragment">
precision mediump float;
    uniform vec4 uLightColor; 

    void main(void) 
        {
        gl_FragColor = uLightColor; 
        }
</script>
<script type="text/javascript" src="scripts\gl-matrix\common.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\mat2.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\mat2d.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\mat3.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\mat4.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\vec3.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\vec4.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\quat.js"></script>
<script type="text/javascript" src="scripts\gl-matrix\vec2.js"></script>


<script type="text/javascript" src="scripts\webgl-utils.js"></script>

<script type="text/javascript" src="scripts\Resources\Resource.js"></script>
<script type="text/javascript" src="scripts\Resources\ShaderResource.js"></script>

<script type="text/javascript" src="scripts\GlobalConstants.js"></script>
<script type="text/javascript" src="scripts\Controller.js"></script>
<script type="text/javascript" src="scripts\CameraController.js"></script>
<script type="text/javascript" src="scripts\RobotController.js"></script>
<script type="text/javascript" src="scripts\Transform.js"></script>
<script type="text/javascript" src="scripts\TransformStack.js"></script>
<script type="text/javascript" src="scripts\Scene.js"></script>
<script type="text/javascript" src="scripts\LightManager.js"></script>

<script type="text/javascript" src="scripts\SceneNodes\SceneNodes.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\CameraNode.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\GeometrySceneNodes.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\MeshSceneNodes.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\SkySphereSceneNode.js"></script>
<script type="text/javascript" src="scripts\SceneNodes\PointLightSceneNode.js"></script>

<script type="text/javascript" src="scripts\shaders_setup.js"></script>
<script type="text/javascript" src="scripts\Main.js"></script>
<script type="text/javascript" src="scripts\Resources\QuadResource.js"></script>
<script type="text/javascript" src="scripts\Drawers\TextureDrawer.js"></script>
<script type="text/javascript" src="scripts\Drawers\DeferredDrawer.js"></script>
<script type="text/javascript" src="scripts\Drawers\SSAODrawer.js"></script>

</head>


<body onload="webGLStart();">

    <canvas id="WebGL-canvas" style="border: none;" width="800" height="600"></canvas>

    <br/>

    <h4 id="RenderControlOption">- Control Render Output</br> </br> </h4> 

    <h4 id="SSAOControlOption">- Control SSAO parameters</br> </br> </h4> 

    <h4 id="Instruction">- How to execute on your browser:</h4> 
    <h4>     1. Currently it will only support Google Chrome</br>
             2. Enter about:flags in address bar.</br>
             3. Find the field "WebGL 2.0 Prototype" and enable it.
        </h4> 

</body>


</html>

